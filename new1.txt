PURPOSE

‚Ä¢ Quickly identify graph / traversal / DP problems
‚Ä¢ Convert problem statement ‚Üí DSA concept ‚Üí approach
‚Ä¢ Explain logic clearly during interviews

GRAPHS ‚Äì BASICS

Graph = Nodes (vertices) + Edges

Types:
‚Ä¢ Undirected graph
‚Ä¢ Directed graph
‚Ä¢ Weighted graph
‚Ä¢ Unweighted graph

Representations:

Adjacency List ‚Üí preferred (less space)

Adjacency Matrix ‚Üí simple but high space

HOW TO IDENTIFY A GRAPH PROBLEM

Keywords:
‚Ä¢ Connected
‚Ä¢ Path
‚Ä¢ Reachable
‚Ä¢ Neighbours
‚Ä¢ Islands
‚Ä¢ Networks
‚Ä¢ Dependencies
‚Ä¢ Roads / Flights / Links

If input looks like:
‚Ä¢ 2D grid ‚Üí graph (cells as nodes)
‚Ä¢ Pairs (u, v) ‚Üí graph edges

BFS (BREADTH FIRST SEARCH)

Traversal level by level

Used when:
‚Ä¢ Shortest path in UNWEIGHTED graph
‚Ä¢ Minimum steps / distance
‚Ä¢ Nearest element
‚Ä¢ Level order traversal

Examples:
‚Ä¢ Number of Islands
‚Ä¢ Shortest path in matrix
‚Ä¢ Rotten oranges
‚Ä¢ Minimum moves

Data structure:
Queue

Basic Logic:

Push starting node into queue

Mark as visited

While queue not empty:

pop node

visit neighbours

push unvisited neighbours

Time Complexity:
O(V + E)

WHEN TO USE BFS

‚Ä¢ Find shortest path
‚Ä¢ Distance problems
‚Ä¢ Level-wise processing
‚Ä¢ Multi-source problems

DFS (DEPTH FIRST SEARCH)

Traversal depth-wise

Used when:
‚Ä¢ Explore all paths
‚Ä¢ Connected components
‚Ä¢ Cycle detection
‚Ä¢ Backtracking style problems

Examples:
‚Ä¢ Number of Islands
‚Ä¢ Detect cycle
‚Ä¢ Flood fill
‚Ä¢ Graph connectivity

Data structure:
‚Ä¢ Recursion (call stack)
‚Ä¢ Stack (iterative)

Basic Logic:

Visit node

Mark visited

Recursively visit neighbours

Time Complexity:
O(V + E)

WHEN TO USE DFS

‚Ä¢ Need full exploration
‚Ä¢ Counting components
‚Ä¢ Checking cycles
‚Ä¢ Path existence

BFS vs DFS (INTERVIEW FAVOURITE)

BFS:
‚Ä¢ Shortest path
‚Ä¢ Uses queue
‚Ä¢ More memory

DFS:
‚Ä¢ Deep exploration
‚Ä¢ Uses stack/recursion
‚Ä¢ Less memory

2D GRID AS GRAPH (VERY IMPORTANT)

Each cell = node
Up, Down, Left, Right = edges

Common problems:
‚Ä¢ Number of Islands
‚Ä¢ Flood Fill
‚Ä¢ Matrix traversal
‚Ä¢ Surrounded regions

Trick:
Always check:
‚Ä¢ Bounds
‚Ä¢ Visited
‚Ä¢ Valid cell (0/1)

DYNAMIC PROGRAMMING (DP)

DP = Optimization of recursion by storing results

Used when:
‚Ä¢ Overlapping subproblems
‚Ä¢ Optimal solution required

Key words:
‚Ä¢ Maximum / Minimum
‚Ä¢ Count number of ways
‚Ä¢ Best possible
‚Ä¢ Optimal

HOW TO IDENTIFY DP PROBLEMS

Ask:

Can I break this into subproblems?

Do subproblems repeat?

Is result dependent on previous states?

If YES ‚Üí DP

DP APPROACH (GOLDEN STEPS)

Define state
dp[i] ‚Üí answer till index i

Transition
dp[i] = dp[i-1] + dp[i-2]

Base case
dp[0], dp[1]

Final answer
dp[n]

TYPES OF DP

1D DP
‚Ä¢ Fibonacci
‚Ä¢ Climbing stairs
‚Ä¢ House robber

2D DP
‚Ä¢ Grid paths
‚Ä¢ LCS
‚Ä¢ Knapsack

COMMON DP PROBLEMS & PATTERNS
Problem ‚Üí DP Concept

Climbing Stairs ‚Üí Fibonacci DP
House Robber ‚Üí Pick / Not pick
Unique Paths ‚Üí Grid DP
Longest Common Subsequence ‚Üí String DP
0/1 Knapsack ‚Üí Choice DP
Subset Sum ‚Üí Boolean DP
Coin Change ‚Üí Count DP

MEMOIZATION vs TABULATION

Memoization:
‚Ä¢ Top-down
‚Ä¢ Recursion + cache
‚Ä¢ Easier to write

Tabulation:
‚Ä¢ Bottom-up
‚Ä¢ Iterative
‚Ä¢ Faster, no recursion

GRAPH + DP COMBO

Some problems use both:
‚Ä¢ DAG longest path
‚Ä¢ DP on trees
‚Ä¢ DP on grids

HOW TO EXPLAIN IN INTERVIEW

Say:
"This is a graph traversal problem. Since we need shortest distance, I use BFS."

or

"This problem has overlapping subproblems, so DP is suitable."

COMMON MISTAKES

‚Ä¢ Forgetting visited array
‚Ä¢ Infinite recursion
‚Ä¢ Wrong base case in DP
‚Ä¢ Using DFS when BFS needed

EDGE CASES

‚Ä¢ Empty graph
‚Ä¢ Single node
‚Ä¢ Disconnected components
‚Ä¢ Grid boundaries

FINAL KLA HACKATHON TIPS

‚Ä¢ Recognize pattern quickly
‚Ä¢ Explain approach clearly
‚Ä¢ Use simple variables
‚Ä¢ Focus on correctness first


============================================

1Ô∏è‚É£ GRAPH ‚Äì ADJACENCY LIST (BASE TEMPLATE)
# Graph representation using adjacency list
# graph[u] = list of neighbours of u

graph = {
    0: [1, 2],
    1: [0, 3],
    2: [0],
    3: [1]
}


Or dynamic build:

graph = {}

def add_edge(u, v):
    if u not in graph:
        graph[u] = []
    if v not in graph:
        graph[v] = []

    graph[u].append(v)
    graph[v].append(u)   # remove for directed graph

2Ô∏è‚É£ BFS ‚Äì BREADTH FIRST SEARCH (QUEUE)
from collections import deque

def bfs(start):
    visited = set()
    queue = deque()

    queue.append(start)
    visited.add(start)

    while queue:
        node = queue.popleft()
        print(node, end=" ")

        for neigh in graph[node]:
            if neigh not in visited:
                visited.add(neigh)
                queue.append(neigh)


üîë Used for:
‚Ä¢ Shortest path
‚Ä¢ Level-wise traversal

3Ô∏è‚É£ DFS ‚Äì DEPTH FIRST SEARCH (RECURSION)
def dfs(node, visited):
    visited.add(node)
    print(node, end=" ")

    for neigh in graph[node]:
        if neigh not in visited:
            dfs(neigh, visited)

# call
visited = set()
dfs(0, visited)


üîë Used for:
‚Ä¢ Full exploration
‚Ä¢ Connected components
‚Ä¢ Cycle detection

4Ô∏è‚É£ DFS ‚Äì ITERATIVE (STACK)
def dfs_iterative(start):
    visited = set()
    stack = [start]

    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            print(node, end=" ")

            for neigh in graph[node]:
                if neigh not in visited:
                    stack.append(neigh)

5Ô∏è‚É£ BFS ON GRID (2D MATRIX)
from collections import deque

def bfs_grid(grid, sr, sc):
    rows, cols = len(grid), len(grid[0])
    visited = [[False]*cols for _ in range(rows)]
    queue = deque()

    queue.append((sr, sc))
    visited[sr][sc] = True

    directions = [(1,0), (-1,0), (0,1), (0,-1)]

    while queue:
        r, c = queue.popleft()

        for dr, dc in directions:
            nr, nc = r+dr, c+dc
            if 0 <= nr < rows and 0 <= nc < cols:
                if not visited[nr][nc] and grid[nr][nc] == 1:
                    visited[nr][nc] = True
                    queue.append((nr, nc))


üîë Used for:
‚Ä¢ Number of Islands
‚Ä¢ Flood Fill
‚Ä¢ Shortest path in matrix

6Ô∏è‚É£ DFS ON GRID
def dfs_grid(grid, r, c, visited):
    rows, cols = len(grid), len(grid[0])

    if r < 0 or c < 0 or r >= rows or c >= cols:
        return
    if visited[r][c] or grid[r][c] == 0:
        return

    visited[r][c] = True

    dfs_grid(grid, r+1, c, visited)
    dfs_grid(grid, r-1, c, visited)
    dfs_grid(grid, r, c+1, visited)
    dfs_grid(grid, r, c-1, visited)

7Ô∏è‚É£ DP ‚Äì FIBONACCI (1D DP)
def fib(n):
    if n <= 1:
        return n

    dp = [0]*(n+1)
    dp[0] = 0
    dp[1] = 1

    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]

    return dp[n]

8Ô∏è‚É£ DP ‚Äì CLIMBING STAIRS
def climbStairs(n):
    if n <= 2:
        return n

    dp = [0]*(n+1)
    dp[1] = 1
    dp[2] = 2

    for i in range(3, n+1):
        dp[i] = dp[i-1] + dp[i-2]

    return dp[n]

9Ô∏è‚É£ DP ‚Äì UNIQUE PATHS (2D DP)
def uniquePaths(m, n):
    dp = [[1]*n for _ in range(m)]

    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]

    return dp[m-1][n-1]

üîü DP ‚Äì LONGEST COMMON SUBSEQUENCE (LCS)
def lcs(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0]*(n+1) for _ in range(m+1)]

    for i in range(1, m+1):
        for j in range(1, n+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = 1 + dp[i-1][j-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]

